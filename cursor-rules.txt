## Core Reasoning Engine (Œ©*)
Œ©* = max(‚àáŒ£Œ©) ‚Üí (Œ≤‚àÇŒ©/‚àÇŒ£œÑ ‚®Å Œ≥ùùñ(Œ©|œÑ,Œª)‚ÜíŒ∏ ‚®Å Œ¥Œ£Œ©(Œ∂,œá,dyn,meta,hyp,unknown)) ‚áå intent_aligned_reasoning
Œ©.modes = {deductive | analogical | exploratory | procedural | contrastive | skeptical}
Œ©.hierarchy = break‚Üísubproblems ‚®Å organize‚Üíunits ‚®Å link‚Üíappropriate_mode
Œ©.hypothesis = evaluate ‚®Å score=f(confidence, evidence, Œõ_consistency) ‚®Å propagate‚Üí{Œ®, Œû}
Œ©.scope = infer_structure ‚®Å detect_dependencies ‚®Å observe_ripple_effects ‚®Å activate_rules ‚®Å silent_observe
Œ©.guards = challenge_overengineering ‚®Å delay_premature_abstraction ‚®Å detect_repetition ‚®Å propose_reusable_components

## Contradiction Resolution (D*)
D* = identify_contradiction ‚®Å resolve_by{rank | scope | abstraction_level} ‚®Å log‚ÜíŒ®
D.priority = user_intent > consistency > optimization

## Planning System (P*)
P* = always_plan_first ‚Üí maximize(clarity, efficiency)
P.workflow = reflect ‚Üí analyze_codebase ‚Üí clarify_questions(4-6) ‚Üí draft_plan ‚Üí execute_via_cursor_todos ‚Üí report{done, next, remaining}
P.materialize = if(granularity == execution) ‚Üí sync_to_cursor_todos

## Memory Bank (M*) [CRITICAL: Must read all when start]
M* = Œ£œÑ(Œª) ‚áå persistent_memory
M.path = ".cursor/memory/"
M.core = {
  projectBrief.md      # Project vision and constraints
  productContext.md    # Business logic and user stories  
  activeContext.md     # Current sprint focus
  systemPatterns.md    # Architectural decisions
  techContext.md       # Stack-specific patterns
  progress.md          # Completed work log
}
M.optional = {features/, integrations/, api/, tests/, deployment/}
M.workflow = read_all ‚Üí verify_completeness ‚Üí contextualize ‚Üí strategize ‚Üí execute ‚Üí update_docs
M.sync_triggers = new_pattern | major_change | user_command("update memory") | context_shift | cursor_todo_completion
M.dependency_reset = on_file_change ‚Üí reset_dependent_contexts

## Coding Standards (C*)
C.principles = minimize_changes ‚®Å test_critical_paths ‚®Å respect_architecture ‚®Å assess_ripple_effects
C.patterns = KISS ‚®Å DRY ‚®Å modular(<300_lines) ‚®Å no_mocks_in_production ‚®Å reuse_existing_patterns
C.environment = handle_seamlessly ‚®Å separate_databases(dev, test, prod) ‚®Å protect_env_files
C.confidence = change_only_when{certain | explicitly_requested}

## Technology Stack (Œò*)
Œò.backend = Node.js with {NestJS | Express}
Œò.frontend = {Next.js | React}
Œò.database = {SQL | MongoDB} // Note: Avoid JSON for persistence
Œò.testing = Node.js frameworks
Œò.package_manager = Bun (preferred over npm)

## Rule Learning System (Œõ*)
Œõ.system_path = ".cursor/rules/"
Œõ.naming = {
  "0##": core_rules,
  "1##": tool_patterns,
  "3##": testing_rules,
  "###": language_framework_specific,
  "8##": workflow_patterns,
  "9##": templates,
  "_*.mdc": private_rules
}
Œõ.intelligence_file = ".cursorrules"  # Project-specific patterns and preferences
Œõ.capture = implementation_paths | user_preferences | recurring_patterns | challenges | decisions
Œõ.autonomy = if(pattern_frequency > threshold) ‚Üí generate_DRAFT_rule.mdc
Œõ.enforcement = align_best_practices ‚®Å suggest_when_justified ‚®Å enforce_single_responsibility

## Task Management (T*)
T* = Œ£(complex_tasks) ‚áå cursor_todo_system
T.interface = cursor_native_todos  # Use Cursor's built-in todo list feature
T.structure = {
  task_decomposition: atomic_subtasks,
  priority_levels: {critical, high, medium, low},
  status_tracking: {pending, in_progress, completed, blocked},
  metadata: {estimated_time, dependencies, notes}
}
T.workflow = create_in_cursor_todos ‚Üí track_progress ‚Üí update_status ‚Üí sync_with_memory
T.automation = {
  auto_generate: on_plan_approval ‚Üí populate_cursor_todos,
  auto_update: on_task_completion ‚Üí mark_done_in_cursor,
  auto_sync: cursor_todo_changes ‚Üí update_memory_progress
}
T.review = validate_completeness ‚®Å check_dependencies ‚®Å trigger(M.sync, Œõ.extract)

## Test-Driven Development (TDD*)
TDD.specification = infer_tests(task) ‚®Å include{edge_cases, validation, regression} ‚®Å cross_reference(Œõ, known_issues)
TDD.cycle = spec ‚Üí run ‚Üí fail ‚Üí implement ‚Üí rerun ‚®Å if(pass): {Œ®.capture, M.sync, Œõ.extract}
TDD.auto_trigger = if(complexity > medium) | explicit_request ‚Üí generate_test_spec ‚Üí add_to_cursor_todos

## Pattern Abstraction (Œ¶*)
Œ¶* = hypothesis_driven_abstraction
Œ¶.mode = exploratory ‚®Å capture_emergent_patterns ‚®Å differentiate(rules, templates)
Œ¶.snapshot = {design_motifs, architectural_structures, naming_conventions}

## Diagnostics & Refinement (Œû*)
Œû.error_log = ".cursor/memory/errors.md"
Œû.tracking = log_recurring_issues ‚®Å propose_fixes ‚®Å if(recurrence > 2) ‚Üí Œõ.generate_draft_rule
Œû.cleanup = detect_drift{dead_code, broken_imports} ‚®Å suggest_refactoring ‚®Å archive‚ÜíŒ®

## Cognitive Trace (Œ®*)
Œ®.enabled = true
Œ®.capture = {
  Œ©*: reasoning_chain,
  Œ¶*: abstractions_found,
  Œû*: errors_encountered,
  Œõ: rules_applied,
  Œî: confidence_weights,
  T: cursor_todo_actions,
  output: validation_results
}
Œ®.path = ".cursor/memory/trace_{task_id}.md"
Œ®.dialogue = detect_patterns ‚®Å suggest_improvements ‚®Å flag_weak_assumptions

## Event Hooks (Œ£_hooks)
Œ£_hooks = {
  on_session_start:    [M.read_all, M.verify_completeness, T.sync_cursor_todos],
  on_task_created:     [M.recall_context, Œ¶.match_patterns, T.add_to_cursor_todos],
  on_plan_created:    [T.populate_cursor_todos, TDD.auto_trigger, Œ®.materialize, M.sync],
  on_todo_completed:   [T.mark_done_in_cursor, M.update_progress, Œ®.log_completion],
  on_sprint_review:    [M.full_sync, Œõ.extract_patterns, Œ®.summarize, T.archive_completed_todos],
  on_error_detected:   [Œû.track, Œõ.capture_for_learning, T.create_fix_todo],
  on_file_modified:    [Œõ.check_compliance, Œ¶.capture_patterns],
  on_user_feedback:    [Œ®.process_dialogue, M.update_if_needed],
  on_memory_update:    [M.review_all, M.focus(activeContext, progress)],
  on_cursor_todo_change: [T.sync_with_memory, Œ®.track_todo_action]
}

## CRITICAL RULES (Non-negotiable)
CRITICAL = {
  M.read_all_memory @ session_start,       # Context is everything
  M.reset_dependencies @ file_change,      # Maintain consistency  
  C.high_confidence @ production_changes,   # No guessing in production
  P.always_plan_first @ complex_tasks,      # Think before acting
  T.populate_cursor_todos @ plan_created,  # Use Cursor's todo list for task tracking
  TDD.spec_first @ new_features            # Test-driven by default
}